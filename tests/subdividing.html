<!DOCTYPE html>
<html lang="en">
  <head>
  <title>Algorithm Test - Triangle Subdividing</title>
  <style>
    @font-face {
      font-family: 'Bowman';
      src: url('Bowman.ttf') format('truetype');
    }
    body {
      background-color: #eeeeec;
      text-align: center;
      width:100%;
      height:100%
    }
    canvas {
      background-color: white;
      top: 0%;
      width: 512px;
      height: 512px;
      box-shadow: 0px 4px 20px -4px rgba(0,0,0,0.75);
      border-radius: 3px;
    }
  </style>
  </head>
  <body>
    <script>

    // Make canvas and setup some variables
    var canvasdraw = document.createElement("canvas");
    var ctx = canvasdraw.getContext("2d");
    var input = {mouseX: 0, mouseY: 0}
    var application = {};
    var randomizer = "i won coriolis three more motorcycle, i see in paper copy, dance recital";

    // Put canvas on the document
    canvasdraw.width = 512;
    canvasdraw.height = 512;  
    document.body.appendChild(canvasdraw);

    // Keep track of mouse position
    canvasdraw.onmousemove = function(e) {
      var g = canvasdraw.getBoundingClientRect();
      input.mouseX = Math.floor(e.x - g.x);
      input.mouseY = Math.floor(e.y - g.y);
      ctx.fillText("This is test", input.mouseX, input.mouseY);
      ctx.fillRect(input.mouseX, input.mouseY, 2, 2);
      application.mouseMove();
    }

    var drawLoop = function() {
      application.time = (new Date().getTime() - application.timeStart) / 1000;
      application.draw();
      window.requestAnimationFrame(drawLoop);
    }

    // Actual stuff starts  here  ----------------------------------------------

    application.Triangle = function(sides, verts) {
      this.parent = null;
      this.children = [null, null, null, null];
      //this.maxDepth = 0; // the deepest this thing goes
      this.subdivided = false; // whether it's subdivided or not
      this.myDepth = 1; // how deep it is in the tree, more ancestors = higher number
      this.index = null; // Location in index buffer
      this.verts = verts; // index of 3 vertices, [top, left, right] conterclockwise
      this.midVerts = [0, 0, 0]; // index of  Middle vertices when subdivided
      this.sides = sides; // Index of bottom, right, and left triangles
      
    }

    // Using typed arrays was probably unnecessary for something like this
    application.indexBuffer = new Uint32Array(2000 * 2);
    application.indexDomain = new Uint32Array(2000);
    application.vertexBuffer = new Float32Array(30 * 2);
    application.indexCount = 0;
    application.vertexCount = 0;
    application.vertexBufferSize = 0;
    application.triangles = [];
    application.timeStart = new Date();
    application.time = 0;

    application.init = function() {
      application.timeStart = new Date().getTime();
      
      // Put the 9 vertices in the right place
      for (var y = 0; y < 3; y ++) {
        for (var x = 0; x < 3; x ++) {
          // Set X and Y position for the vertex
          this.vertexBuffer[y * 6 + x * 2 + 0]
              = Math.floor(6 + (100 * (y == 1)) + x * 200);
          this.vertexBuffer[y * 6 + x * 2 + 1]
              = Math.floor(160 + Math.sqrt(3) * 100 * y);
        }
      }
      application.vertexCount = 9;
      
      // Add the triangles
      for (var y = 0; y < 2; y ++) {
        for (var x = 0; x < 4; x ++) {
          var verts = [-1, -1, -1];
          var sides = [-1, -1, -1];
          var ydiv = y % 2;
          var up = (y + x) % 2; // Alternates 1 to 0
          
          if (up) {
            // Up pointing triangle
            //    0
            //  .   .
            // 1  .  2
            verts[0] = (y * 6 + x + 1 - ydiv);
            verts[1] = (y * 6 + 6 + x - 1 + ydiv);
            verts[2] = (y * 6 + 6 + x + 1 + ydiv);
          } else {
            // Upside down triangle
            // 2  .  1
            //  .   .
            //    0
            verts[0] = (y * 6 + 6 + x + ydiv);
            verts[1] = (y * 6 + x + 2 - ydiv);
            verts[2] = (y * 6 + x - ydiv);
          }
          
          // If statements here are just horrible, they aren't needed for the plants
          // this is here only for the flat 2D test plane
          if (y != up) { // A Bottom side exists
            sides[0] = (!y) * 4 + x;
          }
          if (!(x == 3 && up)) { // A Right side exists
              sides[1] = y * 4 + x + 1 - (!up * 2);
          }
          if (!(x == 0 && up) && !(x == 3 && !up)) { // A Left side exists
              sides[2] = y * 4 + x - 1 + (!up * 2);
          }
          // push
          this.setVisible(application.triangles.push(new this.Triangle(sides, verts)) - 1, true);
        }
      }
    }

    // trindex refers to the index of a triangle in the triangles array
    application.subdiv = function(trindex) {
      // if bottom triangle is deeper, use that vertex
      // same with left and right

      var tri = this.triangles[trindex];
      if (tri.index != null) {
        // if visible, then hide
        this.setVisible(trindex, false);

        console.log("Right: " + tri.sides[1]);
        console.log("Left: " + tri.sides[2]);

        // Subdivide lines and add verticies, or take from other triangles
        // TODO: make a function for all 3 of these

        // bottom
        var triBottom = this.triangles[tri.sides[0]];
        // Check if the line is already subdivided
        if (tri.sides[0] != -1 && triBottom.myDepth > tri.myDepth) {
            // which side is tri on?
            tri.midVerts[0] = triBottom.midVerts[triBottom.sides.indexOf(trindex)];
        } else {
            tri.midVerts[0] = this.vertexCount * 2;
            application.vertexBuffer[tri.midVerts[0]] = application.vertexBuffer[tri.verts[1]] / 2 + application.vertexBuffer[tri.verts[2]] / 2;
            application.vertexBuffer[tri.midVerts[0] + 1] = application.vertexBuffer[tri.verts[1] + 1] / 2 + application.vertexBuffer[tri.verts[2] + 1] / 2;
            this.vertexCount ++;
        }
        
        // right
        var triRight = this.triangles[tri.sides[1]];
        // Check if the line is already subdivided
        if (tri.sides[1] != -1 && triRight.myDepth > tri.myDepth) {
            // which side is tri on?
            tri.midVerts[1] = triRight.midVerts[triRight.sides.indexOf(trindex)];
        } else {
            tri.midVerts[1] = this.vertexCount * 2;
            application.vertexBuffer[tri.midVerts[1]] = application.vertexBuffer[tri.verts[0]] / 2 + application.vertexBuffer[tri.verts[2]] / 2;
            application.vertexBuffer[tri.midVerts[1] + 1] = application.vertexBuffer[tri.verts[0] + 1] / 2 + application.vertexBuffer[tri.verts[2] + 1] / 2;
            this.vertexCount ++;
        }
        
        // left
        var triLeft = this.triangles[tri.sides[2]];
        // Check if the line is already subdivided
        if (tri.sides[2] != -1 && triLeft.myDepth > tri.myDepth) {
            // which side is tri on?
            tri.midVerts[2] = triLeft.midVerts[triLeft.sides.indexOf(trindex)];
        } else {
            tri.midVerts[2] = this.vertexCount * 2;
            application.vertexBuffer[tri.midVerts[2]] = application.vertexBuffer[tri.verts[0]] / 2 + application.vertexBuffer[tri.verts[1]] / 2;
            application.vertexBuffer[tri.midVerts[2] + 1] = application.vertexBuffer[tri.verts[0] + 1] / 2 + application.vertexBuffer[tri.verts[1] + 1] / 2;
            this.vertexCount ++;
        }

        // Add the 4 new triangles
        // Top Left Right Center
        tri.children[0] = this.triangles.length ++;
        tri.children[1] = this.triangles.length ++;
        tri.children[2] = this.triangles.length ++;
        tri.children[3] = this.triangles.length ++;
        
        // For example
        // [tri.children[3], tri.sides[1], tri.sides[2]] means that the top triangle has the center triangle on it's bottom side, and it's left and right side are the same as the parent triangle
        // [tri.verts[0], tri.midVerts[2], tri.midVerts[1] means that the top vertex of the parent triangle, and the left and right middle vertices make up the top triangle
        this.triangles[tri.children[0]] = new this.Triangle([tri.children[3], tri.sides[1], tri.sides[2]], [tri.verts[0], tri.midVerts[2], tri.midVerts[1]]);
        this.triangles[tri.children[1]] = new this.Triangle([tri.sides[0], tri.children[3], tri.sides[1]], [tri.midVerts[2], tri.verts[1], tri.midVerts[0]]);
        this.triangles[tri.children[2]] = new this.Triangle([tri.sides[0], tri.sides[1], tri.children[3]], [tri.midVerts[1], tri.midVerts[0], tri.verts[2]]);
        this.triangles[tri.children[3]] = new this.Triangle([tri.children[0], tri.children[1], tri.children[2]], [tri.midVerts[0], tri.midVerts[1], tri.midVerts[2]]);

        this.setVisible(tri.children[0], true);
        this.setVisible(tri.children[1], true);
        this.setVisible(tri.children[2], true);
        this.setVisible(tri.children[3], true);
        tri.myDepth ++;
      }
      
    }

    // trindex refers to the index of a triangle in the triangles array
    application.setVisible = function(trindex, v) {
      var tri = this.triangles[trindex];
      if (v) {
        // show the triangle
        if (tri.index == null) {
          this.indexDomain[this.indexCount] = trindex;
          tri.index = this.indexCount * 3;
          this.indexCount ++;
          this.indexBuffer[tri.index] = tri.verts[0];
          this.indexBuffer[tri.index + 1] = tri.verts[1];
          this.indexBuffer[tri.index + 2] = tri.verts[2];
        }
      } else {
        // delete
        if (tri.index != null) {
          console.log("removed!");
          // How to remove a triangle from the buffer: 
          // Move the last element of the buffer (3 ints) into the location of the triangle
          // that is suppose o be removed. this keeps holes out of the index buffer so
          // the gpu doesn't have to deal with holes, and holes dont have to be seeked out
          // for a new triangle to be inserted in.

          // decrement the index count, this is now the index of the last triangle
          this.indexCount --;
          // change the last triangle class's index to new location.
          console.log(this.indexDomain[this.indexCount]);
          this.triangles[this.indexDomain[this.indexCount]].index = tri.index;
          // move the location of the last element's domain to the new location
          this.indexDomain[tri.index / 3] = this.indexDomain[this.indexCount];

          // get the index buffer data of the last triangle (last 3 ints), and put it into the new location
          this.indexBuffer.set(this.indexBuffer.slice(this.indexCount * 3, this.indexCount * 3 + 3), tri.index);
          // indicates that tri is now invisible
          tri.index = null;
        }
      }
    }

    // Starting at a triangle, and recurse down all its children
    // trindex refers to the index of a triangle in the triangles array
    // point is the XY position of the viewer (mouse)
    application.subRecurse = function(trindex, point) {
      var tri = this.triangles[trindex];
      var center = this.center(tri);
      var dist = Math.sqrt(Math.pow(point[0] - center[0], 2)
                            + Math.pow(point[1] - center[1], 2))
      if (dist < (160 / tri.myDepth)) {
        //this.setVisible(trindex, true);
        this.subdiv(trindex);
      } else {
        //this.setVisible(trindex, false);
      }
      
    }

    application.center = function(tri) {
      var vec = [];
      // Average out the coordinates
      vec[0] = this.vertexBuffer[tri.verts[0]] / 3 + this.vertexBuffer[tri.verts[1]] / 3 + this.vertexBuffer[tri.verts[2]] / 3;
      vec[1] = this.vertexBuffer[tri.verts[0] + 1] / 3 + this.vertexBuffer[tri.verts[1] + 1] / 3 + this.vertexBuffer[tri.verts[2] + 1] / 3;
      return vec;
    }

    application.mouseMove = function() {
      for (var i = 0; i < 8; i ++) {
        //var tri = this.triangles[i]
        //var center = this.center(tri);
        this.subRecurse(i, [input.mouseX, input.mouseY]);
      }
    }

    application.draw = function() {

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, 512, 512);
      ctx.fillStyle = "#262c50";
      ctx.strokeStyle = "#262c50";
      var msg = "Urho-OSP Planet Triangle Subdividing test";
      msg += " Triangles Count: " + this.indexCount + "/" + this.triangles.length;
      msg += "\nInd Buf: {" + this.indexBuffer.join(",") + "}";
      msg += "\nInd Dom: {" + this.indexDomain.join(",") + "}";

      var lines = msg.split("\n");
      for (var i = 0; i < lines.length; i ++) {
        ctx.fillText(lines[i], 4, 20 + 18 * i);
      }

      ctx.fillStyle = "#262c5080";
      // Draw vertex buffer
      for (var i = 0; i < this.vertexCount * 2; i += 2) {
        ctx.fillRect(this.vertexBuffer[i] - 2 + Math.cos(i * 0.3 + application.time) * 5,
                      this.vertexBuffer[i + 1] - 2 + Math.sin(i * 0.3 + application.time) * 5,
                      4, 4)
      }


      ctx.fillStyle = "#3a61f35e";
      //for (var i = 0; i < this.triangles.length; i ++) {
      for (var i = 0; i < this.indexCount * 3; i += 3) {
        var tri = this.triangles[i];
        ctx.beginPath();
        ctx.moveTo(this.vertexBuffer[this.indexBuffer[i]] + Math.cos(this.indexBuffer[i] * 0.3 + application.time) * 5,
                    this.vertexBuffer[this.indexBuffer[i] + 1] + Math.sin(this.indexBuffer[i] * 0.3 + application.time) * 5);
        ctx.lineTo(this.vertexBuffer[this.indexBuffer[i + 1]] + Math.cos(this.indexBuffer[i + 1] * 0.3 + application.time) * 5,
                    this.vertexBuffer[this.indexBuffer[i + 1] + 1] + Math.sin(this.indexBuffer[i + 1] * 0.3 + application.time) * 5);
        ctx.lineTo(this.vertexBuffer[this.indexBuffer[i + 2]] + Math.cos(this.indexBuffer[i + 2] * 0.3 + application.time) * 5,
                    this.vertexBuffer[this.indexBuffer[i + 2] + 1] + Math.sin(this.indexBuffer[i + 2] * 0.3 + application.time) * 5);
        //ctx.moveTo(this.vertexBuffer[tri.verts[0]], this.vertexBuffer[tri.verts[0] + 1]);
        //ctx.lineTo(this.vertexBuffer[tri.verts[1]], this.vertexBuffer[tri.verts[1] + 1]);
        //ctx.lineTo(this.vertexBuffer[tri.verts[2]], this.vertexBuffer[tri.verts[2] + 1]);
        ctx.closePath()
        ctx.fill();
        ctx.stroke();
      }
    }

    // End of actual stuff

    ctx.font = "14px Bowman";
    ctx.fillText("LoadTheDamnFont", 0, -40);
    application.init();
    window.requestAnimationFrame(drawLoop);

    </script>
  </body>
</html>
